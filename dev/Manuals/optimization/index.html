<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimization · TransportMaps.jl</title><meta name="title" content="Optimization · TransportMaps.jl"/><meta property="og:title" content="Optimization · TransportMaps.jl"/><meta property="twitter:title" content="Optimization · TransportMaps.jl"/><meta name="description" content="Documentation for TransportMaps.jl."/><meta property="og:description" content="Documentation for TransportMaps.jl."/><meta property="twitter:description" content="Documentation for TransportMaps.jl."/><meta property="og:url" content="https://juliauq.github.io/TransportMaps.jl/Manuals/optimization/"/><meta property="twitter:url" content="https://juliauq.github.io/TransportMaps.jl/Manuals/optimization/"/><link rel="canonical" href="https://juliauq.github.io/TransportMaps.jl/Manuals/optimization/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TransportMaps.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manuals</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../basis_functions/">Basis Functions</a></li><li><a class="tocitem" href="../map_parameterization/">Map Parameterization</a></li><li><a class="tocitem" href="../quadrature_methods/">Quadrature Methods</a></li><li class="is-active"><a class="tocitem" href>Optimization</a><ul class="internal"><li><a class="tocitem" href="#Map-from-density"><span>Map-from-density</span></a></li><li><a class="tocitem" href="#Map-from-samples"><span>Map-from-samples</span></a></li></ul></li><li><a class="tocitem" href="../conditional_densities/">Conditional Densities and Samples</a></li><li><a class="tocitem" href="../adaptive_transport_map/">Adaptive Transport Maps</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../Examples/banana_mapfromdensity/">Banana: Map from Density</a></li><li><a class="tocitem" href="../../Examples/banana_mapfromsamples/">Banana: Map from Samples</a></li><li><a class="tocitem" href="../../Examples/banana_adaptive/">Banana: Adaptive Transport Map from Samples</a></li><li><a class="tocitem" href="../../Examples/cubic_adaptive_fromdensity/">Cubic: Adaptive Transport Map from Density</a></li><li><a class="tocitem" href="../../Examples/bod_bayesianinference/">Bayesian Inference: BOD</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/bases/">Bases</a></li><li><a class="tocitem" href="../../api/rectifiers/">Rectifiers</a></li><li><a class="tocitem" href="../../api/densities/">Reference and Target Densities</a></li><li><a class="tocitem" href="../../api/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../api/maps/">Maps</a></li><li><a class="tocitem" href="../../api/optimization/">Optimization</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manuals</a></li><li class="is-active"><a href>Optimization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimization</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaUQ/TransportMaps.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaUQ/TransportMaps.jl/blob/main/docs/literate/Manuals/optimization.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimization-of-the-Map-Coefficients"><a class="docs-heading-anchor" href="#Optimization-of-the-Map-Coefficients">Optimization of the Map Coefficients</a><a id="Optimization-of-the-Map-Coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-of-the-Map-Coefficients" title="Permalink"></a></h1><p>A crucial step in constructing transport maps is the optimization of the map coefficients, which determine how well the map represents the target distribution. This process can be approached in two distinct ways, depending on the available information about the target distribution [<a href="../../references/#marzouk2016">1</a>].</p><h2 id="Map-from-density"><a class="docs-heading-anchor" href="#Map-from-density">Map-from-density</a><a id="Map-from-density-1"></a><a class="docs-heading-anchor-permalink" href="#Map-from-density" title="Permalink"></a></h2><p>One way to construct a transport map is to directly optimize its parameters based on the (unnormalized) target density, as shown in <a href="../../Examples/banana_mapfromdensity/#Banana:-Map-from-Density">Banana: Map from Density</a>. This approach requires access to the target density function and uses quadrature schemes to approximate integrals, as introduced in <a href="../quadrature_methods/#Quadrature-Methods">Quadrature Methods</a>.</p><p>Formally, we define the following optimization problem to determine the coefficients <span>$\boldsymbol{a}$</span> of the parameterized map <span>$T$</span>:</p><p class="math-container">\[\min_{\boldsymbol{a}} \sum_{i=1}^{N} w_{q,i}\Big[-\log\pi\bigl(T(\boldsymbol{a},\boldsymbol{z}_{q,i})\bigr)-\log |\det\nabla T(\boldsymbol{a},\boldsymbol{z}_{q,i}) |\Big]\]</p><p>As noted by [<a href="../../references/#marzouk2016">1</a>], this optimization problem is generally non-convex. Specifically, it is only convex when the target density <span>$\pi(\boldsymbol{x})$</span> is log-concave. Especially in Bayesian inference, where the target density represents the posterior density, the function is not log-concave, resulting in a non-convex optimization problem.</p><p>In this package, map optimization is performed with the help of <a href="https://julianlsolvers.github.io/Optim.jl/stable/"><code>Optim.jl</code></a>, and support a wide range of optimizers and options (such as convergence criteria and printing preferences). Specifically, we can pass our <code>optimize!</code> function the desired <code>optimizer</code> and <code>options</code>. For a full overview of available options, see the <a href="https://julianlsolvers.github.io/Optim.jl/stable/user/config/">Optim.jl configuration documentation</a>.</p><p>To perform the optimization of the map coefficients, we call:</p><pre><code class="language-julia hljs">optimize!(M::PolynomialMap, target_density::Function, quadrature::AbstractQuadratureWeights;
  optimizer::Optim.AbstractOptimizer = LBFGS(), options::Optim.Options = Optim.Options())</code></pre><p>We have to provide the polynomial map <code>M</code>, the target density function, and a quadrature scheme. Optionally, we can specify the optimizer (default is <code>LBFGS()</code>) and options.</p><div class="admonition is-info" id="Set-initial-coefficients-f41ef1f83c5d5dc5"><header class="admonition-header">Set initial coefficients<a class="admonition-anchor" href="#Set-initial-coefficients-f41ef1f83c5d5dc5" title="Permalink"></a></header><div class="admonition-body"><p>As the starting point of the optimization, the map coefficients can be set using <code>setcoefficients!(M, coeffs)</code>, where <code>coeffs</code> is a vector of coefficients.</p></div></div><h3 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h3><p>First we load the packages:</p><pre><code class="language-julia hljs">using TransportMaps
using Optim
using Distributions
using Plots</code></pre><p>Then, define the target density and quadrature scheme. Here, we use the same banana-shaped density as in <a href="../../Examples/banana_mapfromdensity/#Banana:-Map-from-Density">Banana: Map from Density</a>:</p><pre><code class="language-julia hljs">banana_density(x) = logpdf(Normal(), x[1]) + logpdf(Normal(), x[2] - x[1]^2)
target = MapTargetDensity(banana_density)
quadrature = GaussHermiteWeights(10, 2)</code></pre><p>Set optimization options to print the trace every 20 iterations:</p><pre><code class="language-julia hljs">opts_trace = Optim.Options(iterations=200, show_trace=true, show_every=20, store_trace=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">                x_abstol = 0.0
                x_reltol = 0.0
                f_abstol = 0.0
                f_reltol = 0.0
                g_abstol = 1.0e-8
          outer_x_abstol = 0.0
          outer_x_reltol = 0.0
          outer_f_abstol = 0.0
          outer_f_reltol = 0.0
          outer_g_abstol = 1.0e-8
           f_calls_limit = 0
           g_calls_limit = 0
           h_calls_limit = 0
       allow_f_increases = true
 allow_outer_f_increases = true
        successive_f_tol = 1
              iterations = 200
        outer_iterations = 1000
             store_trace = true
           trace_simplex = false
              show_trace = true
          extended_trace = false
           show_warnings = true
              show_every = 20
                callback = nothing
              time_limit = NaN
</code></pre><p>We will try the following optimizers from <code>Optim.jl</code>, ordered from simplest to most sophisticated:</p><h3 id="Gradient-Descent"><a class="docs-heading-anchor" href="#Gradient-Descent">Gradient Descent</a><a id="Gradient-Descent-1"></a><a class="docs-heading-anchor-permalink" href="#Gradient-Descent" title="Permalink"></a></h3><p>The most basic optimization algorithm, Gradient Descent iteratively moves in the direction of the negative gradient. It is simple and robust, but can be slow to converge, especially for ill-conditioned problems.</p><pre><code class="language-julia hljs">M_gd = PolynomialMap(2, 2)
res_gd = optimize!(M_gd, target, quadrature; optimizer=GradientDescent(), options=opts_trace)
println(res_gd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     Function value   Gradient norm
     0     3.397609e+00     4.804530e-01
 * time: 4.220008850097656e-5
    20     2.846750e+00     3.244379e-02
 * time: 0.9251270294189453
    40     2.841985e+00     1.426403e-02
 * time: 1.5243771076202393
    60     2.840998e+00     1.066274e-02
 * time: 2.12786602973938
    80     2.840454e+00     8.088299e-03
 * time: 2.7438080310821533
   100     2.840145e+00     6.198896e-03
 * time: 3.3535361289978027
   120     2.839965e+00     4.786295e-03
 * time: 3.966238021850586
   140     2.839858e+00     3.715940e-03
 * time: 4.562327146530151
   160     2.839794e+00     2.896858e-03
 * time: 5.148483037948608
   180     2.839755e+00     2.265401e-03
 * time: 5.7612810134887695
   200     2.839731e+00     1.775845e-03
 * time: 6.377130031585693
 * Status: failure (reached maximum number of iterations)

 * Candidate solution
    Final objective value:     2.839731e+00

 * Found with
    Algorithm:     Gradient Descent

 * Convergence measures
    |x - x&#39;|               = 3.70e-04 ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 1.52e-04 ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = 9.28e-07 ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 3.27e-07 ≰ 0.0e+00
    |g(x)|                 = 1.78e-03 ≰ 1.0e-08

 * Work counters
    Seconds run:   6  (vs limit Inf)
    Iterations:    200
    f(x) calls:    681
    ∇f(x) calls:   681
    ∇f(x)ᵀv calls: 0</code></pre><h3 id="Conjugate-Gradient"><a class="docs-heading-anchor" href="#Conjugate-Gradient">Conjugate Gradient</a><a id="Conjugate-Gradient-1"></a><a class="docs-heading-anchor-permalink" href="#Conjugate-Gradient" title="Permalink"></a></h3><p>Conjugate Gradient improves upon basic gradient descent by using conjugate directions, which can accelerate convergence for large-scale or quadratic problems. It requires gradient information but not the Hessian.</p><pre><code class="language-julia hljs">M_cg = PolynomialMap(2, 2)
res_cg = optimize!(M_cg, target, quadrature; optimizer=ConjugateGradient(), options=opts_trace)
println(res_cg)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     Function value   Gradient norm
     0     3.397609e+00     4.804530e-01
 * time: 4.1961669921875e-5
    20     2.839693e+00     8.763686e-05
 * time: 0.4553201198577881
    40     2.839693e+00     2.084568e-07
 * time: 0.6624801158905029
 * Status: success

 * Candidate solution
    Final objective value:     2.839693e+00

 * Found with
    Algorithm:     Conjugate Gradient

 * Convergence measures
    |x - x&#39;|               = 9.92e-09 ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 4.01e-09 ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 0.00e+00 ≤ 0.0e+00
    |g(x)|                 = 1.40e-08 ≰ 1.0e-08

 * Work counters
    Seconds run:   1  (vs limit Inf)
    Iterations:    59
    f(x) calls:    141
    ∇f(x) calls:   84
    ∇f(x)ᵀv calls: 0</code></pre><h3 id="Nelder-Mead"><a class="docs-heading-anchor" href="#Nelder-Mead">Nelder-Mead</a><a id="Nelder-Mead-1"></a><a class="docs-heading-anchor-permalink" href="#Nelder-Mead" title="Permalink"></a></h3><p>Nelder-Mead is a derivative-free optimizer that uses a simplex of points to search for the minimum. It is useful when gradients are unavailable or unreliable, but may be less efficient for high-dimensional or smooth problems.</p><pre><code class="language-julia hljs">M_nm = PolynomialMap(2, 2)
res_nm = optimize!(M_nm, target, quadrature; optimizer=NelderMead(), options=opts_trace)
println(res_nm)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     Function value    √(Σ(yᵢ-ȳ)²)/n
------   --------------    --------------
     0     3.385910e+00     6.623032e-03
 * time: 5.3882598876953125e-5
    20     3.325296e+00     1.183941e-02
 * time: 0.05847597122192383
    40     3.217172e+00     1.770408e-02
 * time: 0.11845803260803223
    60     3.145470e+00     4.181887e-03
 * time: 0.1972208023071289
    80     3.117131e+00     5.446265e-03
 * time: 0.2381749153137207
   100     3.093431e+00     3.313369e-03
 * time: 0.2932429313659668
   120     3.069929e+00     3.715059e-03
 * time: 0.3255949020385742
   140     3.051885e+00     3.568445e-03
 * time: 0.3717210292816162
   160     3.040074e+00     2.744730e-03
 * time: 0.41947388648986816
   180     3.030321e+00     2.994942e-03
 * time: 0.46205687522888184
   200     3.014241e+00     3.253376e-03
 * time: 0.49709582328796387
 * Status: failure (reached maximum number of iterations)

 * Candidate solution
    Final objective value:     3.008308e+00

 * Found with
    Algorithm:     Nelder-Mead

 * Convergence measures
    √(Σ(yᵢ-ȳ)²)/n ≰ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    200
    f(x) calls:    304</code></pre><h3 id="BFGS"><a class="docs-heading-anchor" href="#BFGS">BFGS</a><a id="BFGS-1"></a><a class="docs-heading-anchor-permalink" href="#BFGS" title="Permalink"></a></h3><p>BFGS is a quasi-Newton method that builds up an approximation to the Hessian matrix using gradient evaluations. It is generally faster and more robust than gradient descent and conjugate gradient for smooth problems.</p><pre><code class="language-julia hljs">M_bfgs = PolynomialMap(2, 2)
res_bfgs = optimize!(M_bfgs, target, quadrature; optimizer=BFGS(), options=opts_trace)
println(res_bfgs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     Function value   Gradient norm
     0     3.397609e+00     4.804530e-01
 * time: 4.291534423828125e-5
 * Status: success

 * Candidate solution
    Final objective value:     2.839693e+00

 * Found with
    Algorithm:     BFGS

 * Convergence measures
    |x - x&#39;|               = 8.52e-09 ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 3.45e-09 ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = 4.44e-16 ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 1.56e-16 ≰ 0.0e+00
    |g(x)|                 = 3.25e-10 ≤ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    12
    f(x) calls:    45
    ∇f(x) calls:   45
    ∇f(x)ᵀv calls: 0</code></pre><h3 id="LBFGS"><a class="docs-heading-anchor" href="#LBFGS">LBFGS</a><a id="LBFGS-1"></a><a class="docs-heading-anchor-permalink" href="#LBFGS" title="Permalink"></a></h3><p>LBFGS is a limited-memory version of BFGS, making it suitable for large-scale problems where storing the full Hessian approximation is impractical. It is the default optimizer in many scientific computing packages due to its efficiency and reliability.</p><pre><code class="language-julia hljs">M_lbfgs = PolynomialMap(2, 2)
res_lbfgs = optimize!(M_lbfgs, target, quadrature; optimizer=LBFGS(), options=opts_trace)
println(res_lbfgs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Iter     Function value   Gradient norm
     0     3.397609e+00     4.804530e-01
 * time: 3.0040740966796875e-5
 * Status: success

 * Candidate solution
    Final objective value:     2.839693e+00

 * Found with
    Algorithm:     L-BFGS

 * Convergence measures
    |x - x&#39;|               = 1.25e-08 ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 5.04e-09 ≰ 0.0e+00
    |f(x) - f(x&#39;)|         = 1.33e-15 ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 4.69e-16 ≰ 0.0e+00
    |g(x)|                 = 2.84e-09 ≤ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit Inf)
    Iterations:    12
    f(x) calls:    45
    ∇f(x) calls:   45
    ∇f(x)ᵀv calls: 0</code></pre><p>Finally, we can compare the results by means of variance diagnostic:</p><pre><code class="language-julia hljs">samples_z = randn(1000, 2)
v_gd = variance_diagnostic(M_gd, target, samples_z)
v_cg = variance_diagnostic(M_cg, target, samples_z)
v_nm = variance_diagnostic(M_nm, target, samples_z)
v_bfgs = variance_diagnostic(M_bfgs, target, samples_z)
v_lbfgs = variance_diagnostic(M_lbfgs, target, samples_z)

println(&quot;Variance diagnostic GradientDescent:   &quot;, v_gd)
println(&quot;Variance diagnostic ConjugateGradient: &quot;, v_cg)
println(&quot;Variance diagnostic NelderMead:        &quot;, v_nm)
println(&quot;Variance diagnostic BFGS:              &quot;, v_bfgs)
println(&quot;Variance diagnostic LBFGS:             &quot;, v_lbfgs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Variance diagnostic GradientDescent:   0.0004373121237130718
Variance diagnostic ConjugateGradient: 0.0003790237201569168
Variance diagnostic NelderMead:        0.10626452172420726
Variance diagnostic BFGS:              0.0003790236351507774
Variance diagnostic LBFGS:             0.0003790236432620713</code></pre><p>We can visualize the convergence of all optimizers:</p><pre><code class="language-julia hljs">plot([res_gd.trace[i].iteration for i in 1:length(res_gd.trace)], lw=2,
    [res_gd.trace[i].g_norm for i in 1:length(res_gd.trace)], label=&quot;GradientDescent&quot;)
plot!([res_cg.trace[i].iteration for i in 1:length(res_cg.trace)], lw=2,
    [res_cg.trace[i].g_norm for i in 1:length(res_cg.trace)], label=&quot;ConjugateGradient&quot;)
plot!([res_nm.trace[i].iteration for i in 1:length(res_nm.trace)], lw=2,
    [res_nm.trace[i].g_norm for i in 1:length(res_nm.trace)], label=&quot;NelderMead&quot;)
plot!([res_bfgs.trace[i].iteration for i in 1:length(res_bfgs.trace)], lw=2,
    [res_bfgs.trace[i].g_norm for i in 1:length(res_bfgs.trace)], label=&quot;BFGS&quot;)
plot!([res_lbfgs.trace[i].iteration for i in 1:length(res_lbfgs.trace)], lw=2,
    [res_lbfgs.trace[i].g_norm for i in 1:length(res_lbfgs.trace)], label=&quot;LBFGS&quot;)
plot!(xaxis=:log, yaxis=:log, xlabel=&quot;Iteration&quot;, ylabel=&quot;Gradient norm&quot;,
    title=&quot;Convergence of different optimizers&quot;, xlims=(1, 200),
    legend=:bottomleft)</code></pre><p><img src="../optimization-conv.svg" alt="Optimization Convergence"/></p><p>It becomes clear, that LBFGS and BFGS are the most efficient optimizers in this case, while Nelder-Mead struggles to keep up.</p><h2 id="Map-from-samples"><a class="docs-heading-anchor" href="#Map-from-samples">Map-from-samples</a><a id="Map-from-samples-1"></a><a class="docs-heading-anchor-permalink" href="#Map-from-samples" title="Permalink"></a></h2><p>Another strategy of constructing a transport map is to use samples of the target density, as seen in <a href="../../Examples/banana_mapfromsamples/#Banana:-Map-from-Samples">Banana: Map from Samples</a>. The formulation of transport map estimation in this way has the benefit to transform the problem into a convex optimization problem, when reference density is log-concave [<a href="../../references/#marzouk2016">1</a>]. Since we can choose the reference density, we can leverage this property to simplify the optimization process.</p><p>When the map is constructed from samples, the optimization problem is formulated by minimizing the Kullback-Leibler divergence between the pushforward of the reference density and the empirical distribution of the samples. We denote the transport map by <span>$S$</span>, which pushes forward the target distribution to the reference distribution. This leads to the following optimization problem:</p><p class="math-container">\[\min_{\boldsymbol{a}} -\frac{1}{M} \sum_{i=1}^{M} \log \rho\left(S(\boldsymbol{a}, \boldsymbol{x}_i)\right) - \log \left|\det \nabla S(\boldsymbol{a}, \boldsymbol{x}_i)\right|\]</p><p>where <span>$\{\boldsymbol{x}_i\}_{i=1}^M$</span> are samples from the target distribution, and <span>$\rho(\cdot)$</span> is the density of the reference distribution.</p><p>To perform the optimization, we can use the same <code>optimize!</code> function as before, but now we pass samples instead of a target density and quadrature scheme. Similarly, we can specify the optimizer and options:</p><pre><code class="language-julia hljs">optimize!(M::PolynomialMap, samples::AbstractArray{&lt;:Real};
  optimizer::Optim.AbstractOptimizer = LBFGS(), options::Optim.Options = Optim.Options())</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quadrature_methods/">« Quadrature Methods</a><a class="docs-footer-nextpage" href="../conditional_densities/">Conditional Densities and Samples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 16 January 2026 10:32">Friday 16 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
